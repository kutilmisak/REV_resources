<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tutoriál Mikrokontroléry (MCU)</title>
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; line-height: 1.6; margin: 0; display: flex; background: #f9f9f9; color: #333; }
        
        /* Navigace - Původní styl */
        nav { width: 280px; background: #2c3e50; height: 100vh; position: fixed; padding: 20px; color: white; overflow-y: auto; }
        nav h2 { font-size: 1.4rem; border-bottom: 1px solid #555; padding-bottom: 10px; }
        nav ul { list-style: none; padding: 0; }
        nav li { margin-bottom: 12px; }
        nav a { text-decoration: none; color: #ecf0f1; font-size: 0.95rem; transition: 0.3s; }
        nav a:hover { color: #3498db; padding-left: 5px; }

        /* Obsah */
        main { margin-left: 320px; padding: 40px; max-width: 900px; background: white; min-height: 100vh; box-shadow: -5px 0 15px rgba(0,0,0,0.05); }
        h1 { color: #2c3e50; border-left: 5px solid #3498db; padding-left: 15px; }
        h2 { color: #2980b9; margin-top: 40px; border-bottom: 1px solid #eee; }
        code { background: #eee; padding: 2px 5px; border-radius: 4px; font-family: monospace; }
        .section { margin-bottom: 60px; }
		
		/* Styl pro responzivní obrázky */
		img {
			max-width: 100%;
			height: auto;
			display: block;
			margin: 20px auto; /* Vycentrování a mezera kolem */
			border-radius: 8px; /* Jemné zaoblení pro moderní vzhled */
			box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Volitelný stín */
		}
				
        @media (max-width: 768px) {
            body { flex-direction: column; }
            nav { width: 100%; height: auto; position: relative; }
            main { margin-left: 0; padding: 20px; }
        }
    </style>
</head>
<body>

    <nav>
        <h2 style="color: #d3d3d3;">MCU Základy</h2>
        <ul>
            <li><a href="#intro">1. Co je Mikrokontrolér?</a></li>
            <li><a href="#workflow">2. Vývoj (Host vs Target)</a></li>
			<li><a href="#binary-path">3. Instrukce</a></li>
            <li><a href="#memory">4. Paměť a Flashování</a></li>
			<li><a href="#gpio">5. GPIO: Vstup a Výstup</a></li>
			<li><a href="#tcb-timer">6. Timer TCB a přerušení (ISR)</a></li>
			<li><a href="#uart">7. UART: Sériová komunikace</a></li>
			<li><a href="#analog">8. Analogové periferie: ADC, DAC a VREF</a></li>
			<li><a href="#comm-bus">9. Sériové sběrnice: SPI a I2C</a></li>
			<li><a href="#pwm-tca">10. PWM a Timer TCA (Dual-slope)</a></li>
			<li><a href="#evsys">11. Event System: Hardwarová automatizace</a></li>
			<li><a href="#system-stability">12. Stabilita a úspora: WDT a Sleep</a></li>
        </ul>
    </nav>

    <main>
<section id="intro" class="section">
    <h1>1. Mikrokontrolér (MCU) a jeho architektura</h1>
    <p>
        Mikrokontrolér je monolitický integrovaný obvod integrující procesorové jádro, paměťové subsystémy a periferie na jediném čipu. Na rozdíl od desktopových CPU je navržen pro deterministické řízení v reálném čase.
    </p>

    <h3>Blokové schéma a funkční celky</h3>
    <p>Z pohledu programátora je MCU definován svou vnitřní strukturou a způsobem, jakým CPU komunikuje s okolím:</p>

    <img src="mcu.jpg" alt="model MCU">

    <div class="grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 20px;">
        <div>
            <h4>Výpočetní a řídicí jádro CPU</h4>
            <ul>
                <li><strong>ALU (Arithmetic Logic Unit):</strong> Implementace aritmetických a logických operací nad daty v registrech.</li>
                <li><strong>Registry:</strong> Sada nízkoúrovňových paměťových míst přímo v jádře. Konfigurace celého systému probíhá zápisem/čtením specifických řídicích registrů (Memory-Mapped I/O).</li>
            </ul>
        </div>
        <div>
            <h4>Paměťový subsystém</h4>
            <ul>
                <li><strong>Flash (Non-volatile):</strong> Paměť pro uložení binárního kódu a konstant. Data zůstávají zachována i bez napájení.</li>
                <li><strong>SRAM (Volatile):</strong> Rychlá pracovní paměť pro data (heap, stack). Po ztrátě napájení dochází k vymazání obsahu.</li>
            </ul>
        </div>
    </div>

    <h3>Hardwarové zajištění běhu</h3>
    <ul>
        <li><strong>Oscilátor (Clock Source):</strong> Zdroj hodinového signálu definující taktovací frekvenci procesoru a synchronizaci periferií.</li>
        <li><strong>Debug Interface (SWD / JTAG):</strong> Fyzické rozhraní pro on-chip debugging, umožňující přístup k interním stavům CPU, paměti a registrům během běhu.</li>
        <li><strong>Power Management:</strong> Systém napájení (typicky 1.8V až 5V) s integrovanými regulátory a funkcemi pro reset při poklesu napětí (Brown-out reset).</li>
    </ul>
</section>

<section id="workflow" class="section">
    <h1>3. Vývojový proces: Host vs. Target</h1>
    <p>
        Při vývoji embedded systémů pracujeme tak, že kód píšeme na výkonném počítači, ale výsledný program běží na malém čipu s omezenými zdroji.
    </p>

    <div style="display: flex; gap: 20px; margin: 30px 0; align-items: stretch;">
        <div style="flex: 1; background: #f8f9fa; border: 1px solid #dee2e6; padding: 20px; border-radius: 8px;">
            <h4 style="color: #2c3e50; margin-top: 0;">Host Machine (PC)</h4>
            <p>Váš počítač (Windows/Linux/Mac). Zde probíhá:</p>
            <ul>
                <li>Psaní zdrojového kódu (typicky v <strong>jazyce C</strong>).</li>
                <li>Správa projektu v IDE.</li>
                <li>Samotný proces kompilace.</li>
            </ul>
        </div>
        <div style="display: flex; align-items: center; font-size: 2rem; color: #3498db;">➔</div>
        <div style="flex: 1; background: #eef7fd; border: 1px solid #3498db; padding: 20px; border-radius: 8px;">
            <h4 style="color: #2c3e50; margin-top: 0;">Target Device (MCU)</h4>
            <p>Cílový mikrokontrolér. Zde probíhá:</p>
            <ul>
                <li>Běh zkompilované binárky.</li>
                <li>Interakce s fyzickým hardwarem.</li>
                <li>Omezený prostor v řádech KB/MB.</li>
            </ul>
        </div>
    </div>

    <h3>1. Jazyk C v embedded</h3>
    <p>
        Ačkoliv existují alternativy (C++, Rust), <strong>jazyk C</strong> zůstává standardem. Nabízí ideální poměr mezi čitelností pro lidi a přímým přístupem k hardwarovým registrům bez zbytečné režie (overheadu).
    </p>

    <h3>2. Cross-Compiler (Křížový překladač)</h3>
    <p>
        Běžný kompilátor (např. v Visual Studiu) generuje instrukce pro váš procesor v PC (architektura x86). My však potřebujeme <strong>Cross-compiler</strong>. Ten běží na PC, ale generuje instrukce pro úplně jinou architekturu (např. <strong>ARM Cortex-M</strong>).
    </p>
    <ul>
        <li><strong>Vstup:</strong> Soubory <code>.c</code> a <code>.h</code></li>
        <li><strong>Výstup:</strong> Binární soubor (<code>.bin</code>, <code>.hex</code> nebo <code>.elf</code>) – čistá data pro paměť Flash.</li>
    </ul>

    <h3>3. HW Debugger / Programátor</h3>
    <p>
        Potřebujeme prostředníka – fyzické zařízení (<strong>programátor/debugger</strong>), které propojí USB port vašeho počítače s ladicím rozhraním čipu (různá rozhraní: SWD/JTAG).
    </p>
    
    

    <div class="info-box">
        <p><strong>Úloha Debuggeru:</strong></p>
        1. <strong>Flashování:</strong> Zápis binárky do paměti Flash. <br>
        2. <strong>Ladění:</strong> Umožňuje zastavit program v čipu, číst hodnoty z RAM a procházet kód řádek po řádku.
    </div>
</section>

<section id="binary-path" class="section">
    <h2>4 Cesta kódu: C ➔ Assembler ➔ Strojový kód</h2>
    <p>
        Mikrokontrolér nerozumí příkazu <code>if (teplota > 20)</code>. Rozumí pouze specifickým číselným instrukcím uloženým v paměti Flash.
    </p>

    <div style="background: #f4f4f4; padding: 20px; border-radius: 8px;">
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="border-bottom: 2px solid #2c3e50; text-align: left;">
                    <th style="padding: 10px;">Úroveň</th>
                    <th style="padding: 10px;">Ukázka</th>
                    <th style="padding: 10px;">Kdo to čte?</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding: 10px;"><strong>Jazyk C</strong></td>
                    <td style="padding: 10px;"><code>a = b + 5;</code></td>
                    <td style="padding: 10px;">Programátor</td>
                </tr>
                <tr>
                    <td style="padding: 10px;"><strong>Assembler (ASM)</strong></td>
                    <td style="padding: 10px;"><code>ADDS r0, r1, #5</code></td>
                    <td style="padding: 10px;">Low level / Debugger</td>
                </tr>
                <tr>
                    <td style="padding: 10px;"><strong>Strojový kód</strong></td>
                    <td style="padding: 10px;"><code>0x1C48</code> (binárně <code>000111...</code>)</td>
                    <td style="padding: 10px;">Procesor (ALU)</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h3>Co jsou to instrukce?</h3>
    <p>
        Instrukce je základní příkaz, který procesor dokáže vykonat v jednom nebo několika taktech oscilátoru. Každá architektura (ARM, AVR, x86) má svou vlastní <strong>instrukční sadu</strong>.
    </p>

    <div class="info-box">
        <strong>Příklad v Assembleru (ARM Cortex-M):</strong><br>
        <code>LDR r1, [r0]</code> — Načti (Load) hodnotu z adresy v registru r0 do r1.<br>
        <code>ADDS r1, r1, #1</code> — Přičti k hodnotě v r1 jedničku.<br>
        <code>STR r1, [r0]</code> — Ulož (Store) novou hodnotu zpět na původní adresu.
    </div>

    <h3>Proč nás to zajímá?</h3>
    <p>
        Při psaní v C se o tento překlad stará <strong>kompilátor</strong>. Je ale důležité vědět, že:
    </p>
    <ul>
        <li>Jeden řádek v C může vygenerovat desítky instrukcí strojového kódu.</li>
        <li>Při <strong>debuggingu</strong> (ladění) často uvidíte Assembler, když se snažíte zjistit, proč se procesor chová jinak, než jste čekali.</li>
        <li><strong>Binárka (.bin/.hex)</strong>, kterou nahráváte do čipu, je vlastně jen dlouhý seznam těchto číselných instrukcí.</li>
    </ul>
</section>

<section id="memory" class="section">
    <h2>4. Paměť a organizace dat</h2>
    <p>
        Mikrokontroléry rodiny AVR využívají Harvardovu architekturu, která se vyznačuje fyzicky oddělenými adresními prostory pro instrukce programu a pro data.
    </p>

    <table style="width:100%; border-collapse: collapse; margin-bottom: 20px;">
        <thead>
            <tr style="background-color: #f2f2f2; border-bottom: 2px solid #ddd;">
                <th style="padding: 10px; text-align: left;">Segment</th>
                <th style="padding: 10px; text-align: left;">Typ paměti</th>
                <th style="padding: 10px; text-align: left;">Vlastnosti</th>
                <th style="padding: 10px; text-align: left;">Obsah</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;"><strong>Flash</strong></td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Non-volatile</td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Statická, Read-only</td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Programový kód, .rodata</td>
            </tr>
            <tr>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;"><strong>SRAM</strong></td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Volatile</td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Dynamická, R/W</td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">.data, .bss, Stack, Heap</td>
            </tr>
            <tr>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;"><strong>EEPROM</strong></td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Non-volatile</td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Perzistentní, R/W</td>
                <td style="padding: 10px; border-bottom: 1px solid #ddd;">Konfigurace, kalibrace</td>
            </tr>
        </tbody>
    </table>

    

    <h3>4.1 Alokace proměnných v C</h3>
    <p>
        Způsob deklarace proměnné určuje její umístění v paměťové mapě. Kritickým aspektem je inicializace globálních proměnných, která ovlivňuje spotřebu obou typů pamětí.
    </p>

    <pre><code class="language-c">// Sekce .rodata (pouze Flash)
const uint16_t sensor_lut[4] = {10, 20, 30, 40};

// Sekce .data (Flash -> SRAM)
int setpoint = 25;

// Sekce .bss (SRAM, nulováno při startu)
uint16_t adc_buffer[16];

void main(void) {
    // Stack (SRAM, lokální scope)
    uint8_t status; 
}
</code></pre>

</section>

<section id="gpio" class="section">
    <h2>6. GPIO (General Purpose Input/Output)</h2>
    
    <p>
        Piny mikrokontroléru jsou v digitálním režimu definovány třemi parametry: logickou úrovní, směrem toku dat a impedančním stavem. U řady <strong>AVR-Dx</strong> jsou piny organizovány do portů reprezentovaných v paměti jako instance struktury <code>PORT_t</code>.
    </p>

    <div class="grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div style="background: #fdfdfd; padding: 15px; border: 1px solid #ccc;">
            <h4>Elektrické charakteristiky</h4>
            <ul>
                <li><strong>V<sub>IH</sub> / V<sub>IL</sub>:</strong> Rozhodovací úrovně pro logickou 1 a 0.</li>
                <li><strong>Source / Sink:</strong> Proudové limity pinu (typicky do 20mA).</li>
                <li><strong>Hi-Z:</strong> Stav vysoké impedance při konfiguraci jako vstup (vysoký vstupní odpor, minimální proudový odběr).</li>
            </ul>
        </div>
        <div style="background: #fdfdfd; padding: 15px; border: 1px solid #ccc;">
            <h4>Konfigurační registry</h4>
            <ul>
                <li><strong>DIR:</strong> Data Direction Register (0 = IN, 1 = OUT).</li>
                <li><strong>OUT:</strong> Output Value Register.</li>
                <li><strong>IN:</strong> Input Value Register (čtení stavu synchronizátoru).</li>
                <li><strong>PINnCTRL:</strong> Per-pin Configuration (Pull-up, Invert, Input Sense).</li>
            </ul>
        </div>
    </div>

    

    <h3>6.1 Registry pro atomickou manipulaci</h3>
    <p>
        Architektura AVR-Dx implementuje hardwarové aliasy pro zápis do registrů <code>DIR</code> a <code>OUT</code>. Tyto aliasy umožňují modifikaci jednotlivých bitů bez nutnosti instrukcí pro bitový posuv a logický součet/součin v CPU, což zamezuje hazardním stavům při souběhu s přerušením.
    </p>

    <table style="width:100%; border-collapse: collapse; margin-top: 10px;">
        <thead>
            <tr style="background-color: #f2f2f2; border-bottom: 2px solid #ddd;">
                <th style="padding: 8px; text-align: left;">Suffix</th>
                <th style="padding: 8px; text-align: left;">Funkce</th>
                <th style="padding: 8px; text-align: left;">Operace</th>
            </tr>
        </thead>
        <tbody>
            <tr><td><code>SET</code></td><td>Atomic Set</td><td>Logická 1 na dané pozici nastaví bit, ostatní nemění.</td></tr>
            <tr><td><code>CLR</code></td><td>Atomic Clear</td><td>Logická 1 na dané pozici vynuluje bit, ostatní nemění.</td></tr>
            <tr><td><code>TGL</code></td><td>Atomic Toggle</td><td>Logická 1 na dané pozici neguje stav bitu.</td></tr>
        </tbody>
    </table>

    <h3>6.2 Implementace v C</h3>

    <pre><code class="language-c">// Přímá manipulace s registry portu PA
#include &lt;avr/io.h&gt;

void gpio_setup(void) {
    // Definice PA3 jako výstup (nastavení bitu 3 v registru DIR)
    PORTA.DIRSET = PIN3_bm;

    // Aktivace vnitřního pull-up rezistoru na PA4
    // PINnCTRL registry jsou přístupné jako pole prvků struktury
    PORTA.PIN4CTRL = PORT_PULLUPEN_bm;
}

void gpio_output_control(void) {
    PORTA.OUTSET = PIN3_bm; // PA3 -> LOG 1
    PORTA.OUTCLR = PIN3_bm; // PA3 -> LOG 0
    PORTA.OUTTGL = PIN3_bm; // PA3 -> Inverze stavu
}

uint8_t read_input(void) {
    // Čtení aktuálního stavu portu
    return (PORTA.IN & PIN4_bm);
}</code></pre>

    <blockquote style="border-left: 5px solid #666; padding-left: 10px; margin-top: 20px;">
        <strong>Poznámka:</strong> Použití <code>OUTTGL</code> pro negaci stavu pinu je efektivnější než sekvence <code>PORTA.OUT ^= PIN3_bm</code>, protože nevyžaduje čtení a následný zápis registru v CPU, ale je provedeno přímo logikou portu v jediném hodinovém cyklu.
    </blockquote>
</section>

<section id="tcb-timer" class="section">
<h1>7. Časovače (Timery) a přerušení</h1>
    
    <h3>Obecná charakteristika periferie</h3>
    <p>
        <strong>Timer/Counter</strong> je autonomní hardwarový modul, který nezávisle na CPU inkrementuje (nebo dekrementuje) hodnotu ve svém čítači v rytmu hodinového signálu. Na rozdíl od softwarového čekání (např. funkce <code>_delay_ms()</code>), které plně vytěžuje procesor prázdnými instrukcemi, běží časovač na pozadí a umožňuje CPU vykonávat jinou výpočetní činnost nebo přejít do úsporného režimu.
    </p>

    <p>
        V embedded systémech plní časovače tři základní role:
    </p>
    <ul>
        <li><strong>Časování (Timing):</strong> Generování přesných časových intervalů nebo periodických událostí.</li>
        <li><strong>Čítání (Counting):</strong> Sledování počtu vnějších událostí (pulzů) na vstupním pinu.</li>
        <li><strong>Modulace (PWM):</strong> Generování signálů s proměnnou střídou pro řízení výkonu (např. jas LED, otáčky motoru).</li>
    </ul>
	
	<p>
    <strong>TCB (Timer/Counter B)</strong> je 16bitová periferie určená pro měření a časování specifických událostí. Zatímco hlavní 16bitový časovač TCA je navržen pro generování vícenásobných PWM signálů, TCB je zjednodušená, vysoce přesná jednotka určená pro:
</p>
	
<ul>
    <li><strong>Periodic Interrupt:</strong> Generování časové báze (např. systémový tick pro RTOS).</li>
    <li><strong>Input Capture:</strong> Měření délky pulzu (např. signál z dálkového ovládání nebo senzoru).</li>
    <li><strong>Frequency Measurement:</strong> Měření periody vstupního signálu.</li>
    <li><strong>Single Shot:</strong> Vygenerování jednoho impulzu s přesnou délkou.</li>
</ul>



<h3>Klíčový koncept: Jak vzniká přerušení?</h3>
<p>
    Přerušení (Interrupt) je mechanismus, kdy hardware pozastaví vykonávání hlavní smyčky <code>while(1)</code>, odskočí do speciální funkce (ISR) a po jejím skončení se vrátí zpět. Tím je zajištěn <strong>deterministický časový průběh</strong> kritických úloh, které nesmí být ovlivněny délkou běhu hlavní smyčky.
</p>

<div class="info-box">
    <strong>Příklad:</strong> Pro řízení soustavy v reálném čase (např. PID regulátor) potřebujeme vzorkovat data v přesných intervalech. Timer TCB počítá pulzy oscilátoru a při dosažení hodnoty <code>CCMP</code> vyvolá ISR, která zajistí výpočet regulace nezávisle na zbytku programu.
</div>
    
    <h3>7.1 Mechanismus přerušení (Interrupt Service Routine)</h3>
    <p>
        Přerušení je hardwarový mechanismus umožňující pozastavení vykonávání hlavní programové smyčky a okamžité předání řízení dedikované funkci (ISR). Po ukončení ISR dojde k obnovení stavu procesoru a pokračování v původní sekvenci instrukcí.
    </p>

    <div class="grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <div style="background: #fdfdfd; padding: 15px; border: 1px solid #ccc;">
            <h4>Polling (Dotazování)</h4>
            <ul>
                <li>Periodické čtení stavu v hlavní smyčce.</li>
                <li>Vysoká latence závislá na délce <code>while(1)</code>.</li>
                <li>Zbytečné vytížení CPU i v době nečinnosti.</li>
            </ul>
        </div>
        <div style="background: #fdfdfd; padding: 15px; border: 1px solid #ccc;">
            <h4>Interrupt (Přerušení)</h4>
            <ul>
                <li>Asynchronní reakce vyvolaná hardwarem.</li>
                <li>Minimální latence (určena dobou uložení kontextu).</li>
                <li>Efektivní správa výkonu (možnost využití Sleep módů).</li>
            </ul>
        </div>
    </div>

    

    <h3>7.2 Časovač TCB (Timer/Counter B)</h3>
    <p>
        TCB0 je 16bitový časovač optimalizovaný pro precizní měření času a generování periodických událostí. V režimu <strong>Periodic Interrupt</strong> dochází k inkrementaci čítače až do shody s hodnotou v registru <code>CCMP</code>, což vyvolá příznak přerušení.
    </p>

	<h3>Konfigurace TCB0 pro periodické přerušení</h3>
    <p>
        Při frekvenci periferních hodin f<sub>CLK_PER</sub> = 4 MHz odpovídá hodnota 4000-1 v registru <code>CCMP</code> periodě 1 ms.
    </p>
    <p>
        Aby TCB fungoval jako časovač, musíme nastavit jeho mód na <strong>Periodic Interrupt</strong>.
    </p>

    <pre><code class="language-c">#include &lt;avr/io.h&gt;
#include &lt;avr/interrupt.h&gt;

void timer_init(void) {
    // Definice periody (Top value)
    TCB0.CCMP = 3999; 

    // Povolení přerušení při přetečení (Capture/Compare Interrupt Enable)
    TCB0.INTCTRL = TCB_CAPT_bm; 

    // Konfigurace: Zdroj hodin CLK_PER, režim Periodic Interrupt, zapnutí timeru
    TCB0.CTRLA = TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm; 
    
    // Globální povolení přerušení v CPU (SREG I-bit)
    sei(); 
}</code></pre>

    <h3>7.4 Implementace ISR</h3>
    <p>
        V xc8 se obsluha přerušení definuje makrem <code>ISR()</code> s příslušným vektorem. Pro korektní funkci je nutné v rámci ISR provést manuální kvitování (clear) příznaku v registru <code>INTFLAGS</code>.
    </p>

    <pre><code class="language-c">// Vektor přerušení pro TCB0
ISR(TCB0_INT_vect) {
    // Kvitování přerušení zápisem log. 1 do příznakového registru
    TCB0.INTFLAGS = TCB_CAPT_bm;

    // Fyzická akce: Negace výstupu portu
    PORTA.OUTTGL = PIN3_bm;
}</code></pre>

    

    <h3>7.5 Kritická pravidla pro ISR</h3>
    <ul>
        <li><strong>Délka vykonávání:</strong> ISR musí být maximálně efektivní. Komplexní výpočty nebo čekací smyčky (delay) v přerušení blokují ostatní procesy a systémové časování.</li>
        <li><strong>Kvalifikátor volatile:</strong> Proměnné sdílené mezi ISR a hlavní smyčkou musí být deklarovány jako <code>volatile</code>, aby se zabránilo nežádoucím optimalizacím kompilátoru při čtení z registrů.</li>
        <li><strong>Atomicita:</strong> Při přístupu k vícebajtovým proměnným, které mění ISR, musí být v hlavní smyčce dočasně zakázána přerušení (kritická sekce), aby nedošlo k přečtení nekonzistentních dat.</li>
    </ul>
</section>

<section id="uart" class="section">
    <h1>8. UART (Universal Asynchronous Receiver-Transmitter)</h1>
    
    <h3>Obecný princip a asynchronní přenos</h3>
    <p>
        UART je sériový komunikační protokol, který k přenosu dat využívá pouze dva vodiče: <strong>TX</strong> (Transmit) a <strong>RX</strong> (Receive). Označení <strong>asynchronní</strong> znamená, že rozhraní nesdílí společný hodinový signál (Clock). 
    </p>

    

    <p>
        Aby komunikace fungovala, musí se obě strany předem dohodnout na parametrech:
    </p>
    <ul>
        <li><strong>Baudrate:</strong> Přenosová rychlost (počet symbolů za sekundu). Typické hodnoty jsou 9600 nebo 115200 bps.</li>
        <li><strong>Frame Format:</strong> Struktura datového rámce (počet datových bitů, parita, počet stop bitů). Nejčastější je formát <strong>8N1</strong> (8 datových bitů, žádná parita, 1 stop bit).</li>
        <li><strong>Start/Stop bity:</strong> Protože neexistuje sdílený Clock, začátek přenosu signalizuje Start bit, který synchronizuje přijímač s vysílačem.</li>
    </ul>

    <h3>UART na AVR128DB48 (USART Periferie)</h3>
    <p>
        U čipů řady AVR-Dx se periferie označuje jako <strong>USART</strong>, protože podporuje i synchronní režim. Pro základní komunikaci s PC však využíváme asynchronní mód.
    </p>

    

    <h3>Výpočet Baudrate</h3>
    <p>
        Hodnota pro registr <code>BAUD</code> se vypočítá na základě frekvence periferií ($f_{CLK\_PER}$) a požadované rychlosti ($BAUD_{rate}$). Pro asynchronní režim (16x oversampling) platí vztah:
        $$BAUD_{reg} = \frac{64 \cdot f_{CLK\_PER}}{S \cdot BAUD_{rate}}$$
        Kde $S$ je počet vzorků na bit (typicky 16). 
    </p>

    <h3>Implementace v C</h3>
    <p>
        Příklad inicializace USART3 (který je na AVR128DB48 Curiosity Nano kitu připojen k USB převodníku) a funkce pro odeslání znaku:
    </p>

    <pre><code class="language-c">#include &lt;avr/io.h&gt;

void uart_init(uint32_t baudrate) {
    // 1. Nastavení pinu TX (PB0) jako výstupní
    PORTB.DIRSET = PIN0_bm;
    
    // 2. Výpočet a nastavení Baudrate (pro 4MHz takt a 9600 bps)
    // Výsledek (64 * 4000000) / (16 * 9600) = 1666
    USART3.BAUD = (uint16_t)((64 * 4000000) / (16 * baudrate));
    
    // 3. Povolení vysílače (Transmitter)
    USART3.CTRLB = USART_TXEN_bm;
}

void uart_send_char(char c) {
    // Čekání na vyprázdnění vysílacího bufferu (DRE - Data Register Empty)
    while (!(USART3.STATUS & USART_DREIF_bm));
    
    // Zápis dat do registru spustí samotný fyzický přenos
    USART3.TXDATAL = c;
}

void uart_send_string(const char* str) {
    while (*str) {
        uart_send_char(*str++);
    }
}</code></pre>

    <div class="info-box">
        <strong>Poznámka k registrům:</strong> Registr <code>STATUS</code> obsahuje příznak <code>DREIF</code>, který nám říká, zda je hardware připraven přijmout další bajt k odeslání. Pokud bychom do <code>TXDATAL</code> zapsali dříve, než se předchozí bajt odešle, data by byla přepsána.
    </div>
</section>


<section id="analog" class="section">
    <h1>9. Analogové periferie: ADC, DAC a VREF</h1>
    <p>
        Mikrokontroléry AVR-Dx umožňují precizní práci s analogovým signálem. Klíčem k úspěchu je pochopení vztahu mezi referenčním napětím, rozlišením a reálnou hodnotou v milivoltech.
    </p>

    <h3>1. ADC (Analog-to-Digital Converter)</h3>
    <p>
        ADC převádí vstupní napětí na digitální číslo. AVR128DB48 disponuje <strong>12bitovým ADC</strong>, což znamená, že rozsah mezi 0V a referencí dělí na 4096 kroků.
    </p>
    
    

    <div style="background: #f8f9fa; padding: 15px; border-left: 5px solid #2ecc71; margin: 15px 0;">
        <strong>Vztah pro výpočet:</strong><br>
        <code>Digitální hodnota = (V_vstup / V_ref) * 4095</code>
    </div>

    <h3>2. DAC (Digital-to-Analog Converter)</h3>
    <p>
        DAC provádí opačný proces – z digitálního čísla vytvoří na pinu reálné napětí. U řady AVR-Dx je DAC <strong>10bitový</strong> (rozsah 0 až 1023). Je ideální pro generování funkcí nebo řízení analogových obvodů.
    </p>

    <h3>3. VREF (Voltage Reference)</h3>
    <p>
        Referenční napětí definuje stabilitu a přesnost převodu. AVR128DB48 má interní referenční zdroj, který lze softwarově přepínat (např. 1.024V, 2.048V, 2.5V, 4.096V).
    </p>

    

    <h3>Implementace pro AVR128DB48</h3>
    <pre><code class="language-c">#include &lt;avr/io.h&gt;

void analog_init(void) {
    // 1. Konfigurace VREF: Nastavení 2.048V pro ADC0
    VREF.ADC0CTRLA = VREF_REFSEL_2V048_gc;
    
    // 2. Konfigurace ADC: 12-bit, povolit, dělička hodin 16
    ADC0.CTRLA = ADC_RESSEL_12BIT_gc | ADC_ENABLE_bm;
    ADC0.CTRLC = ADC_PRESC_DIV16_gc;
    ADC0.MUXPOS = ADC_MUXPOS_AIN2_gc; // Snímání z pinu PD2
    
    // 3. Konfigurace DAC: Povolit výstup na pin PD6
    VREF.DAC0CTRLA = VREF_REFSEL_2V048_gc; // I DAC potřebuje referenci
    DAC0.CTRLA = DAC_ENABLE_bm | DAC_OUTEN_bm;
}

uint16_t read_adc(void) {
    ADC0.COMMAND = ADC_STCONV_bm;          // Start měření
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm)); // Čekání na výsledek
    return ADC0.RES;                       // 0 až 4095
}

void write_dac(uint16_t value) {
    DAC0.DATAL = (value & 0xFF);           // Zápis 10-bitové hodnoty
    DAC0.DATAH = (value >> 8);
}</code></pre>

    <div class="info-box">
        <strong>Technická poznámka:</strong> Pokud měříte napětí baterie, které může být vyšší než V<sub>REF</sub>, musíte použít odporový dělič napětí, jinak dojde k saturaci ADC nebo poškození pinu.
    </div>
</section>

<section id="comm-bus" class="section">
    <h1>10. Sériové sběrnice: SPI a I2C (TWI)</h1>
    <p>
        Na rozdíl od UARTu jsou sběrnice <strong>SPI</strong> a <strong>I2C</strong> synchronní. To znamená, že sdílejí společný hodinový signál (Clock), což umožňuje mnohem vyšší rychlosti a spolehlivější přenos dat.
    </p>

    <div style="border: 1px solid #ddd; padding: 20px; border-radius: 8px; margin-bottom: 30px;">
        <h2>10.1 SPI (Serial Peripheral Interface)</h2>
        <p>
            SPI je nejrychlejší sběrnice pro komunikaci na krátké vzdálenosti (SD karty, displeje, rychlé ADC). Pracuje v režimu <strong>Full-Duplex</strong> (data tečou oběma směry současně).
        </p>
        
        <h4>Zapojení a vodiče (4-vodičové):</h4>
        <ul>
            <li><strong>SCK (Serial Clock):</strong> Hodinový signál generovaný Masterem.</li>
            <li><strong>MOSI (Master Out Slave In):</strong> Datová linka z Masteru do periferie.</li>
            <li><strong>MISO (Master In Slave Out):</strong> Datová linka z periferie do Masteru.</li>
            <li><strong>SS / CS (Slave Select / Chip Select):</strong> Výběr konkrétního čipu (aktivní v logické 0).</li>
        </ul>

        

        <h4>Implementace na AVR128DB48:</h4>
        <pre><code class="language-c">// Inicializace SPI v režimu Master
void spi_init(void) {
    // 1. Nastavení směrů pinů (MOSI, SCK a SS jako výstupy)
    PORTA.DIRSET = PIN4_bm | PIN6_bm | PIN7_bm;
    
    // 2. Konfigurace SPI: Master, Mode 0, Clock/4
    SPI0.CTRLA = SPI_MASTER_bm | SPI_ENABLE_bm;
}

uint8_t spi_transfer(uint8_t data) {
    SPI0.DATA = data;                      // Start přenosu
    while (!(SPI0.INTFLAGS & SPI_IF_bm));  // Čekání na dokončení
    return SPI0.DATA;                      // Návrat přijatých dat
}</code></pre>
    </div>

    <div style="border: 1px solid #ddd; padding: 20px; border-radius: 8px;">
        <h2>10.2 I2C / TWI (Two-Wire Interface)</h2>
        <p>
            I2C je úsporná sběrnice využívající adresování. Na rozdíl od SPI stačí pro připojení desítek zařízení pouze dva vodiče. Pracuje v režimu <strong>Half-Duplex</strong>.
        </p>

        <h4>Zapojení a vodiče (2-vodičové):</h4>
        <ul>
            <li><strong>SDA (Serial Data):</strong> Obousměrná datová linka.</li>
            <li><strong>SCL (Serial Clock):</strong> Hodinový signál.</li>
        </ul>
        
        <div class="info-box" style="background: #fff3cd; border-left-color: #ffc107;">
            <strong>Důležité:</strong> Linky SDA a SCL jsou typu <strong>Open-Drain</strong>. To znamená, že musí být vždy připojeny k napájecímu napětí přes externí <strong>Pull-up rezistory</strong> (typicky 4.7 k&Omega;).
        </div>

        

        <h4>Adresování a Start/Stop:</h4>
        <p>
            Každá komunikace začíná <strong>START</strong> podmínkou, následuje <strong>7bitová adresa</strong> zařízení a bit pro zápis/čtení (R/W). Zařízení odpovídá bitem <strong>ACK</strong> (Acknowledge).
        </p>

        <h4>Ukázka zápisu na AVR128DB48 (TWI0):</h4>
        <pre><code class="language-c">void i2c_init(void) {
    // Nastavení rychlosti 100 kHz (Standard Mode)
    TWI0.MBAUD = 10; 
    TWI0.MCTRLA = TWI_ENABLE_bm;
    TWI0.MSTATUS = TWI_BUSSTATE_IDLE_gc; // Inicializace stavu sběrnice
}

void i2c_write_byte(uint8_t addr, uint8_t data) {
    // Start + Adresa (bit 0 = 0 pro zápis)
    TWI0.MADDR = addr << 1;
    while (!(TWI0.MSTATUS & TWI_WIF_bm)); // Čekání na odeslání adresy
    
    // Odeslání dat
    TWI0.MDATA = data;
    while (!(TWI0.MSTATUS & TWI_WIF_bm));
    
    // Stop podmínka
    TWI0.MCTRLB = TWI_MCMD_STOP_gc;
}</code></pre>
    </div>
	
	<a href="https://onlinedocs.microchip.com/oxy/GUID-51D4F2DF-E4D3-4379-8E03-9AAF2593C7DA-en-US-3/GUID-97AB089D-37A7-4578-B7E7-D0CB0F755B7E.html">Přejít na web Microchip</a>

    <div class="info-box" style="margin-top: 20px;">
        <strong>Srovnání:</strong> 
        SPI je mnohem rychlejší (jednotky až desítky MHz) a jednodušší na implementaci, ale vyžaduje více vodičů. 
        I2C je pomalejší (standardně 100/400 kHz), ale extrémně úsporné na počet pinů mikrokontroléru.
    </div>
</section>

<section id="pwm-tca" class="section">
    <h1>11. PWM a Timer TCA (Dual-slope režim)</h1>
    
    <h3>Obecný princip: Co je to PWM?</h3>
    <p>
        <strong>PWM (Pulse Width Modulation)</strong> neboli pulzně šířková modulace je technika pro simulaci analogového napětí pomocí digitálního signálu. Rychlým střídáním stavu 0 a 1 vytvoříme průměrnou hodnotu napětí.
    </p>

    

    <ul>
        <li><strong>Perioda (Frekvence):</strong> Jak často se celý cyklus opakuje.</li>
        <li><strong>Střída (Duty Cycle):</strong> Poměr času, kdy je signál v logické 1, k celkové periodě. Vyjadřuje se v procentech (0–100 %).</li>
    </ul>

    <h3>Dual-slope vs. Single-slope</h3>
    <p>
        U AVR128DB48 Timer TCA nabízí režim <strong>Dual-slope PWM</strong>. Na rozdíl od běžného režimu, kdy čítač počítá pouze nahoru (0 &rarr; MAX), v Dual-slope režimu počítá nahoru a hned zase dolů (0 &rarr; MAX &rarr; 0).
    </p>
    
    

    <p><strong>Výhody Dual-slope:</strong></p>
    <ul>
        <li>Symetrické pulzy (střed pulzu je vždy ve stejném místě).</li>
        <li>Poloviční frekvence přepínání při stejném rozlišení, což vede k nižšímu rušení (EMI).</li>
    </ul>

    <h3>Konfigurace TCA0 na AVR128DB48</h3>
    <p>
        V tomto příkladu nastavíme PWM na pinu <strong>PA0</strong> (výstupní kanál WO0 časovače TCA0).
    </p>

    <pre><code class="language-c">#include &lt;avr/io.h&gt;

void pwm_init(void) {
    // 1. Nastavení pinu PA0 jako výstupní
    PORTA.DIRSET = PIN0_bm;

    // 2. Nastavení periody: V Dual-slope je frekvence f = f_clk / (2 * N * PER)
    // Pro f_clk = 4MHz, bez děličky a PER = 2000 bude f_pwm = 1000 Hz
    TCA0.SINGLE.PER = 2000;

    // 3. Nastavení střídy (Compare 0) - např. 50% (1000 z 2000)
    TCA0.SINGLE.CMP0 = 1000;

    // 4. Konfigurace Waveform Generation: Dual-slope PWM, aktivace kanálu 0
    TCA0.SINGLE.CTRLB = TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_WGMODE_DSOP_gc;

    // 5. Spuštění časovače bez děličky (Clock / 1)
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc | TCA_SINGLE_ENABLE_bm;
}

void set_pwm_duty(uint16_t value) {
    // Dynamická změna střídy (např. jas LED)
    if (value <= 2000) {
        TCA0.SINGLE.CMP0 = value;
    }
}</code></pre>

    <div class="info-box" style="border-left-color: #9b59b6; background: #f4eef8;">
        <strong>Kritický rozdíl v registrech:</strong> AVR-Dx používá pro TCA dvě sady registrů – <code>SINGLE</code> a <code>SPLIT</code>. Zde používáme <strong>SINGLE</strong> (jeden 16bitový časovač), který je pro přesné PWM ideální.
    </div>
</section>

<section id="evsys" class="section">
    <h1>12. Event System (EVSYS): Magie bez účasti CPU</h1>
    
    <h3>Obecný princip: Periferie mluví s periferií</h3>
    <p>
        Standardně musí procesor (CPU) hlídat stav periferií: například když přeteče časovač, procesor musí skočit do ISR a tam ručně spustit ADC převod. 
        <strong>Event System</strong> tuto cestu obchází. Umožňuje propojit <strong>Generátor</strong> (např. Timer) přímo s <strong>Uživatelem</strong> (např. ADC) pomocí vnitřních hardwarových kanálů.
    </p>

    

    <h4>Hlavní výhody:</h4>
    <ul>
        <li><strong>Nulová latence:</strong> Reakce na událost proběhne v řádu nanosekund.</li>
        <li><strong>Úspora energie:</strong> CPU může zůstat v režimu spánku (Sleep), zatímco Timer periodicky spouští ADC a ten ukládá data.</li>
        <li><strong>Deterministické časování:</strong> Převody probíhají v naprosto přesných intervalech, neovlivněných jiným běžícím kódem.</li>
    </ul>

    <h3>Praktický scénář: Timer spouští ADC</h3>
    <p>
        V tomto nastavení využijeme <strong>RTC (Real Time Counter)</strong> nebo <strong>Timer TCA</strong> jako generátor události "Overflow". Tato událost skrze kanál 0 spustí měření na ADC0.
    </p>

    

    <h3>Implementace na AVR128DB48</h3>
    <pre><code class="language-c">#include &lt;avr/io.h&gt;

void evsys_init(void) {
    // 1. Nastavení generátoru: Přetečení Timeru TCA0 bude generovat událost
    // Kanál 0 bude přenášet událost z TCA0_OVF
    EVSYS.CHANNEL0 = EVSYS_CHANNEL0_TCA0_OVF_LUN_gc;

    // 2. Nastavení uživatele: ADC0 bude "konzumovat" událost z kanálu 0
    // Tato událost automaticky vyvolá spuštění převodu (Start Conversion)
    EVSYS.USERADC0START = EVSYS_USER_CHANNEL0_gc;
}

void adc_event_init(void) {
    // Konfigurace ADC pro práci s Event Systemem
    // Musíme povolit "Event Control", aby ADC reagovalo na vnější podněty
    ADC0.EVCTRL = ADC_STARTEV_bm; 
    
    // Standardní inicializace ADC (12-bit, zapnutí)
    ADC0.CTRLA = ADC_RESSEL_12BIT_gc | ADC_ENABLE_bm;
}

void timer_for_evsys_init(void) {
    // Nastavení Timeru TCA0 na periodu, ve které chceme vzorkovat (např. 100 Hz)
    TCA0.SINGLE.PER = 40000; 
    TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc | TCA_SINGLE_ENABLE_bm;
}</code></pre>

<h3>Vyzvednutí výsledku: Role ISR</h3>
    <p>
        I když je spuštění převodu plně automatické (Timer &rarr; EVSYS &rarr; ADC), procesor musí výsledek po dokončení převodu přečíst. K tomu využijeme přerušení od ADC (Result Ready).
    </p>

    

    <pre><code class="language-c">// 1. Povolení přerušení v inicializaci ADC
void adc_event_init(void) {
    ADC0.EVCTRL = ADC_STARTEV_bm;           // ADC reaguje na událost z EVSYS
    ADC0.INTCTRL = ADC_RESRDY_bm;           // Povolení přerušení "Result Ready"
    ADC0.CTRLA = ADC_RESSEL_12BIT_gc | ADC_ENABLE_bm;
}

// 2. Obsluha přerušení - zde si CPU vyzvedne hotová data
ISR(ADC0_RESRDY_vect) {
    // Smazání příznaku přerušení proběhne automaticky přečtením registru RES
    uint16_t namerena_hodnota = ADC0.RES;

    // Zde můžeme data zpracovat (např. poslat přes UART)
    process_data(namerena_hodnota);
}</code></pre>

    <div class="info-box" style="background: #e1f5fe; border-left-color: #0288d1;">
        <strong>Klíčový poznatek:</strong> Všimni si, že v kódu není žádná funkce <code>ISR</code> ani <code>while</code> smyčka, která by spouštěla převod. Jakmile tyto tři periferie nastavíš a spustíš timer, data v registru <code>ADC0.RES</code> se budou aktualizovat zcela automaticky.
    </div>
</section>


<section id="system-stability" class="section">
    <h1>15. Systémová stabilita a Power Management</h1>
    
    <h3>15.1 Watchdog Timer (WDT) – Hardwarový dozor</h3>
    <p>
        <strong>Watchdog</strong> je nezávislý časovač, který slouží jako poslední linie obrany. Jeho úkolem je restartovat mikrokontrolér, pokud se software zacyklí nebo selže v důsledku vnějšího rušení. Pokud program pravidelně "nenakrmí" Watchdog, hardware vyvolá <strong>System Reset</strong>.
    </p>

    

    <h4>Bezpečný zápis pomocí ccp_write_io</h4>
    <p>
        U řady AVR-Dx je nastavení Watchdogu chráněno mechanismem <strong>CCP (Configuration Change Protection)</strong>. Pro zápis musíme použít vestavěnou utilitu, která zajistí, že zápis proběhne v kritickém časovém okně 4 instrukčních cyklů.
    </p>

    <pre><code class="language-c">#include &lt;avr/wdt.h&gt;
#include &lt;avr/cpufunc.h&gt; // Nutné pro ccp_write_io

void wdt_init(void) {
    // Bezpečný zápis do chráněného registru CTRLA
    // Nastavení periody na 1 sekundu
    ccp_write_io((void *) &WDT.CTRLA, WDT_PERIOD_1KCLK_gc);
}

int main(void) {
    wdt_init();
    while(1) {
        // Hlavní aplikační smyčka
        do_logic();
        
        // Resetování čítače - "krmení psa"
        wdt_reset();
    }
}</code></pre>

    <hr>

    <h3>15.2 Správa napájení (Sleep Modes)</h3>
    <p>
        Pro snížení spotřeby (např. při provozu z baterie) disponuje AVR128DB48 režimy spánku. Každý režim vypíná jinou část čipu:
    </p>

    <table style="width:100%; border-collapse: collapse; margin: 20px 0;">
        <tr style="background-color: #34495e; color: white;">
            <th style="padding: 10px; border: 1px solid #ddd;">Režim</th>
            <th style="padding: 10px; border: 1px solid #ddd;">Aktivní části</th>
            <th style="padding: 10px; border: 1px solid #ddd;">Vlastnosti</th>
        </tr>
        <tr>
            <td style="padding: 10px; border: 1px solid #ddd;"><strong>Idle</strong></td>
            <td style="padding: 10px; border: 1px solid #ddd;">Periferie, DMA, Event System</td>
            <td style="padding: 10px; border: 1px solid #ddd;">Bleskové probuzení, běží UART i Timery.</td>
        </tr>
        <tr style="background-color: #f9f9f9;">
            <td style="padding: 10px; border: 1px solid #ddd;"><strong>Standby</strong></td>
            <td style="padding: 10px; border: 1px solid #ddd;">Volitelné periferie</td>
            <td style="padding: 10px; border: 1px solid #ddd;">Kompromis mezi spotřebou a funkčností.</td>
        </tr>
        <tr>
            <td style="padding: 10px; border: 1px solid #ddd;"><strong>Power-down</strong></td>
            <td style="padding: 10px; border: 1px solid #ddd;">Pouze WDT a externí přerušení</td>
            <td style="padding: 10px; border: 1px solid #ddd;">Nejnižší spotřeba (&micro;A), zastaveny hlavní hodiny.</td>
        </tr>
    </table>

    

    <h3>15.3 Kombinovaný režim: WDT Interrupt (Budík)</h3>
    <p>
        Watchdog na AVR-Dx umí víc než jen reset. Lze jej nastavit tak, aby místo restartu vyvolal <strong>přerušení</strong>. To je ideální pro probouzení z nejhlubšího spánku (Power-down) v pravidelných intervalech.
    </p>

    <pre><code class="language-c">#include &lt;avr/sleep.h&gt;

void setup_low_power(void) {
    // Nastavení WDT na 8s v režimu přerušení
    ccp_write_io((void *) &WDT.CTRLA, WDT_PERIOD_8KCLK_gc);
    
    // Nastavení typu spánku na nejhlubší možný
    set_sleep_mode(SLEEP_MODE_PWR_DOWN);
}

// ISR, které se zavolá po probuzení Watchdogem
ISR(WDT_vect) {
    // CPU se probudilo, po návratu z ISR pokračuje main
}

int main(void) {
    setup_low_power();
    sei();

    while(1) {
        // Uspání procesoru
        sleep_mode(); 
        
        // --- ZDE CPU SPÍ ---
        
        // Po 8 sekundách se CPU probudí a provede úkol
        measure_and_report();
    }
}</code></pre>

    <div class="info-box" style="background: #e8f5e9; border-left-color: #4caf50;">
        <strong>Tip pro praxi:</strong> V režimu Power-down je spotřeba tak nízká, že největším žroutem proudu bývají piny v nedefinovaném stavu. Před uspáním se ujistěte, že všechny nepoužívané digitální vstupy mají zapnutý Pull-up nebo jsou nastaveny jako výstupy.
    </div>
</section>
		
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
</body>
</html>